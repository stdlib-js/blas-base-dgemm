{
  "version": 3,
  "sources": ["../lib/base.js", "../lib/dgemm.js", "../lib/ndarray.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nvar isRowMajor = require( '@stdlib/ndarray-base-assert-is-row-major' );\nvar ddot = require( '@stdlib/blas-base-ddot' ).ndarray;\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\n\n\n// VARIABLES //\n\nvar bsize = blockSize( 'float64', 'float64' ); // TODO: consider using a larger block size\n\n\n// FUNCTIONS //\n\n/**\n* Tests whether a provided string indicates to transpose a matrix.\n*\n* @private\n* @param {string} str - input string\n* @returns {boolean} boolean indicating whether to transpose a matrix\n*\n* @example\n* var bool = isTransposed( 'transpose' );\n* // returns true\n*\n* @example\n* var bool = isTransposed( 'conjugate-transpose' );\n* // returns true\n*\n* @example\n* var bool = isTransposed( 'no-transpose' );\n* // returns false\n*/\nfunction isTransposed( str ) { // TODO: consider moving to a separate helper utility package\n\treturn ( str !== 'no-transpose' );\n}\n\n/**\n* Fills a matrix with zeros.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows\n* @param {NonNegativeInteger} N - number of columns\n* @param {Float64Array} X - matrix to fill\n* @param {integer} strideX1 - stride of the first dimension of `X`\n* @param {integer} strideX2 - stride of the second dimension of `X`\n* @param {NonNegativeInteger} offsetX - starting index for `X`\n* @returns {Float64Array} input matrix\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* zeros( 2, 3, X, 3, 1, 0 );\n* // X => <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* zeros( 2, 3, X, 1, 2, 0 );\n* // X => <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*/\nfunction zeros( M, N, X, strideX1, strideX2, offsetX ) { // TODO: consider moving to a separate package\n\tvar dx0;\n\tvar dx1;\n\tvar S0;\n\tvar S1;\n\tvar i0;\n\tvar i1;\n\tvar ix;\n\n\tif ( isRowMajor( [ strideX1, strideX2 ] ) ) {\n\t\t// For row-major matrices, the last dimension has the fastest changing index...\n\t\tS0 = N;\n\t\tS1 = M;\n\t\tdx0 = strideX2;                   // offset increment for innermost loop\n\t\tdx1 = strideX1 - ( S0*strideX2 ); // offset increment for outermost loop\n\t} else { // column-major\n\t\t// For column-major matrices, the first dimension has the fastest changing index...\n\t\tS0 = M;\n\t\tS1 = N;\n\t\tdx0 = strideX1;                   // offset increment for innermost loop\n\t\tdx1 = strideX2 - ( S0*strideX1 ); // offset increment for outermost loop\n\t}\n\tix = offsetX;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tX[ ix ] = 0.0;\n\t\t\tix += dx0;\n\t\t}\n\t\tix += dx1;\n\t}\n\treturn X;\n}\n\n/**\n* Scales each element in a matrix by a scalar `\u03B2`.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows\n* @param {NonNegativeInteger} N - number of columns\n* @param {number} beta - scalar\n* @param {Float64Array} X - matrix to fill\n* @param {integer} strideX1 - stride of the first dimension of `X`\n* @param {integer} strideX2 - stride of the second dimension of `X`\n* @param {NonNegativeInteger} offsetX - starting index for `X`\n* @returns {Float64Array} input matrix\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* scal( 2, 3, 5.0, X, 3, 1, 0 );\n* // X => <Float64Array>[ 5.0, 10.0, 15.0, 20.0, 25.0, 30.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var X = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n*\n* scal( 2, 3, 5.0, X, 1, 2, 0 );\n* // X => <Float64Array>[ 5.0, 10.0, 15.0, 20.0, 25.0, 30.0 ]\n*/\nfunction scal( M, N, beta, X, strideX1, strideX2, offsetX ) { // TODO: consider moving to a separate package\n\tvar dx0;\n\tvar dx1;\n\tvar S0;\n\tvar S1;\n\tvar i0;\n\tvar i1;\n\tvar ix;\n\n\tif ( isRowMajor( [ strideX1, strideX2 ] ) ) {\n\t\t// For row-major matrices, the last dimension has the fastest changing index...\n\t\tS0 = N;\n\t\tS1 = M;\n\t\tdx0 = strideX2;                   // offset increment for innermost loop\n\t\tdx1 = strideX1 - ( S0*strideX2 ); // offset increment for outermost loop\n\t} else { // column-major\n\t\t// For column-major matrices, the first dimension has the fastest changing index...\n\t\tS0 = M;\n\t\tS1 = N;\n\t\tdx0 = strideX1;                   // offset increment for innermost loop\n\t\tdx1 = strideX2 - ( S0*strideX1 ); // offset increment for outermost loop\n\t}\n\tix = offsetX;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tX[ ix ] *= beta;\n\t\t\tix += dx0;\n\t\t}\n\t\tix += dx1;\n\t}\n\treturn X;\n}\n\n/**\n* Performs matrix multiplication using a naive algorithm which is cache-optimal when `A` is row-major and `B` is column-major.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in the matrix `op(A)` and in the matrix `C`\n* @param {NonNegativeInteger} N - number of columns in the matrix `op(B)` and in the matrix `C`\n* @param {NonNegativeInteger} K - number of columns in the matrix `op(A)` and number of rows in the matrix `op(B)`\n* @param {number} alpha - scalar constant\n* @param {Float64Array} A - first matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - second matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @param {Float64Array} C - third matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @returns {Float64Array} `C`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( [ 1.0, 1.0, 0.0, 1.0 ] );\n* var C = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* naive( 2, 2, 2, 1.0, A, 2, 1, 0, B, 2, 1, 0, C, 2, 1, 0 );\n* // C => <Float64Array>[ 2.0, 5.0, 6.0, 11.0 ]\n*/\nfunction naive( M, N, K, alpha, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB, C, strideC1, strideC2, offsetC ) {\n\tvar da0;\n\tvar db0;\n\tvar dc0;\n\tvar dc1;\n\tvar S0;\n\tvar S1;\n\tvar i0;\n\tvar i1;\n\tvar ia;\n\tvar ib;\n\tvar ic;\n\n\t// Note on variable naming convention: S#, da#, db#, dc#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tS0 = N;\n\tS1 = M;\n\tda0 = strideA2;\n\tdb0 = strideB1;\n\tdc0 = strideC2;                   // offset increment for innermost loop\n\tdc1 = strideC1 - ( S0*strideC2 ); // offset increment for outermost loop\n\n\tic = offsetC;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tia = offsetA + ( i1*strideA1 );\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tib = offsetB + ( i0*strideB2 );\n\t\t\tC[ ic ] += alpha * ddot( K, A, da0, ia, B, db0, ib );\n\t\t\tic += dc0;\n\t\t}\n\t\tic += dc1;\n\t}\n\treturn C;\n}\n\n/**\n* Performs matrix multiplication using loop tiling.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in the matrix `op(A)` and in the matrix `C`\n* @param {NonNegativeInteger} N - number of columns in the matrix `op(B)` and in the matrix `C`\n* @param {NonNegativeInteger} K - number of columns in the matrix `op(A)` and number of rows in the matrix `op(B)`\n* @param {number} alpha - scalar constant\n* @param {Float64Array} A - first matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - second matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @param {Float64Array} C - third matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @returns {Float64Array} `C`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( [ 1.0, 1.0, 0.0, 1.0 ] );\n* var C = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* blocked( 2, 2, 2, 1.0, A, 2, 1, 0, B, 2, 1, 0, C, 2, 1, 0 );\n* // C => <Float64Array>[ 2.0, 5.0, 6.0, 11.0 ]\n*/\nfunction blocked( M, N, K, alpha, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB, C, strideC1, strideC2, offsetC ) {\n\tvar da0;\n\tvar db0;\n\tvar dc0;\n\tvar dc1;\n\tvar oa1;\n\tvar ob0;\n\tvar oc0;\n\tvar oc1;\n\tvar S0;\n\tvar S1;\n\tvar s0;\n\tvar s1;\n\tvar sk;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar ia;\n\tvar ib;\n\tvar ic;\n\tvar oa;\n\tvar ob;\n\tvar k;\n\n\t// Note on variable naming convention: S#, da#, db#, dc#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tS0 = N;\n\tS1 = M;\n\n\t// Define increments for the innermost loop:\n\tda0 = strideA2;\n\tdb0 = strideB1;\n\tdc0 = strideC2;\n\n\t// Iterate over blocks...\n\tfor ( j1 = S1; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\toa1 = offsetA + ( j1*strideA1 );\n\t\toc1 = offsetC + ( j1*strideC1 );\n\t\tfor ( j0 = S0; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\tob0 = offsetB + ( j0*strideB2 );\n\t\t\toc0 = oc1 + ( j0*strideC2 );      // index offset for `C` for the current block\n\t\t\tdc1 = strideC1 - ( s0*strideC2 ); // loop offset increment for `C`\n\t\t\tfor ( k = K; k > 0; ) {\n\t\t\t\tif ( k < bsize ) {\n\t\t\t\t\tsk = k;\n\t\t\t\t\tk = 0;\n\t\t\t\t} else {\n\t\t\t\t\tsk = bsize;\n\t\t\t\t\tk -= bsize;\n\t\t\t\t}\n\t\t\t\toa = oa1 + ( k*strideA2 );\n\t\t\t\tob = ob0 + ( k*strideB1 );\n\t\t\t\tic = oc0;\n\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\tia = oa + ( i1*strideA1 );\n\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\tib = ob + ( i0*strideB2 );\n\t\t\t\t\t\tC[ ic ] += alpha * ddot( sk, A, da0, ia, B, db0, ib );\n\t\t\t\t\t\tic += dc0;\n\t\t\t\t\t}\n\t\t\t\t\tic += dc1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn C;\n}\n\n\n// MAIN //\n\n/**\n* Performs the matrix-matrix operation `C = \u03B1*op(A)*op(B) + \u03B2*C` where `op(X)` is either `op(X) = X` or `op(X) = X^T`, `\u03B1` and `\u03B2` are scalars, `A`, `B`, and `C` are matrices, with `op(A)` an `M` by `K` matrix, `op(B)` a `K` by `N` matrix, and `C` an `M` by `N` matrix.\n*\n* @private\n* @param {string} transA - specifies whether `A` should be transposed, conjugate-transposed, or not transposed\n* @param {string} transB - specifies whether `B` should be transposed, conjugate-transposed, or not transposed\n* @param {NonNegativeInteger} M - number of rows in the matrix `op(A)` and in the matrix `C`\n* @param {NonNegativeInteger} N - number of columns in the matrix `op(B)` and in the matrix `C`\n* @param {NonNegativeInteger} K - number of columns in the matrix `op(A)` and number of rows in the matrix `op(B)`\n* @param {number} alpha - scalar constant\n* @param {Float64Array} A - first matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - second matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @param {number} beta - scalar constant\n* @param {Float64Array} C - third matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @returns {Float64Array} `C`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( [ 1.0, 1.0, 0.0, 1.0 ] );\n* var C = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* dgemm( 'no-transpose', 'no-transpose', 2, 2, 2, 1.0, A, 2, 1, 0, B, 2, 1, 0, 1.0, C, 2, 1, 0 );\n* // C => <Float64Array>[ 2.0, 5.0, 6.0, 11.0 ]\n*/\nfunction dgemm( transA, transB, M, N, K, alpha, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB, beta, C, strideC1, strideC2, offsetC ) {\n\tvar isrma;\n\tvar isrmb;\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\n\tif ( M === 0 || N === 0 || ( ( beta === 1.0 ) && ( ( alpha === 0.0 ) || ( K === 0 ) ) ) ) {\n\t\treturn C;\n\t}\n\t// Form: C = \u03B2\u22C5C\n\tif ( beta === 0.0 ) {\n\t\tC = zeros( M, N, C, strideC1, strideC2, offsetC );\n\t} else if ( beta !== 1.0 ) {\n\t\tC = scal( M, N, beta, C, strideC1, strideC2, offsetC );\n\t}\n\t// Check whether we can early return...\n\tif ( alpha === 0.0 ) {\n\t\treturn C;\n\t}\n\t// Determine the memory layouts of `A` and `B`...\n\tisrma = isRowMajor( [ strideA1, strideA2 ] );\n\tisrmb = isRowMajor( [ strideB1, strideB2 ] );\n\n\t// Check whether we can avoid loop tiling and simply use the \"naive\" (cache-optimal) algorithm for performing matrix multiplication...\n\tif ( isrma ) { // orderA === 'row-major'\n\t\tif ( !isTransposed( transA ) ) {\n\t\t\tif ( !isrmb && !isTransposed( transB ) ) { // orderB === 'column-major'\n\t\t\t\t// Form: C = \u03B1\u22C5A\u22C5B + C\n\t\t\t\treturn naive( M, N, K, alpha, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB, C, strideC1, strideC2, offsetC );\n\t\t\t}\n\t\t\tif ( isrmb && isTransposed( transB ) ) { // orderB === 'row-major'\n\t\t\t\t// Form: C = \u03B1\u22C5A\u22C5B^T + C\n\t\t\t\treturn naive( M, N, K, alpha, A, strideA1, strideA2, offsetA, B, strideB2, strideB1, offsetB, C, strideC1, strideC2, offsetC );\n\t\t\t}\n\t\t}\n\t} else if ( isTransposed( transA ) ) { // orderA === 'column-major'\n\t\tif ( isrmb && isTransposed( transB ) ) { // orderB === 'row-major'\n\t\t\t// Form: C = \u03B1\u22C5A^T\u22C5B^T + C\n\t\t\treturn naive( M, N, K, alpha, A, strideA2, strideA1, offsetA, B, strideB2, strideB1, offsetB, C, strideC1, strideC2, offsetC );\n\t\t}\n\t\tif ( !isrmb && !isTransposed( transB ) ) { // orderB === 'column-major'\n\t\t\t// Form: C = \u03B1\u22C5A^T\u22C5B + C\n\t\t\treturn naive( M, N, K, alpha, A, strideA2, strideA1, offsetA, B, strideB1, strideB2, offsetB, C, strideC1, strideC2, offsetC );\n\t\t}\n\t}\n\t// Swap strides to perform transposes...\n\tif ( isTransposed( transA ) ) {\n\t\tsa1 = strideA2;\n\t\tsa2 = strideA1;\n\t} else {\n\t\tsa1 = strideA1;\n\t\tsa2 = strideA2;\n\t}\n\tif ( isTransposed( transB ) ) {\n\t\tsb1 = strideB2;\n\t\tsb2 = strideB1;\n\t} else {\n\t\tsb1 = strideB1;\n\t\tsb2 = strideB2;\n\t}\n\t// Perform loop tiling to promote cache locality:\n\treturn blocked( M, N, K, alpha, A, sa1, sa2, offsetA, B, sb1, sb2, offsetB, C, strideC1, strideC2, offsetC );\n}\n\n\n// EXPORTS //\n\nmodule.exports = dgemm;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar max = require( '@stdlib/math-base-special-fast-max' );\nvar isLayout = require( '@stdlib/blas-base-assert-is-layout' );\nvar isMatrixTranspose = require( '@stdlib/blas-base-assert-is-transpose-operation' );\nvar isRowMajor = require( '@stdlib/ndarray-base-assert-is-row-major-string' );\nvar isColumnMajor = require( '@stdlib/ndarray-base-assert-is-column-major-string' );\nvar format = require( '@stdlib/string-format' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Performs the matrix-matrix operation `C = \u03B1*op(A)*op(B) + \u03B2*C` where `op(X)` is either `op(X) = X` or `op(X) = X^T`, `\u03B1` and `\u03B2` are scalars, `A`, `B`, and `C` are matrices, with `op(A)` an `M` by `K` matrix, `op(B)` a `K` by `N` matrix, and `C` an `M` by `N` matrix.\n*\n* @param {string} order - storage layout\n* @param {string} transA - specifies whether `A` should be transposed, conjugate-transposed, or not transposed\n* @param {string} transB - specifies whether `B` should be transposed, conjugate-transposed, or not transposed\n* @param {NonNegativeInteger} M - number of rows in the matrix `op(A)` and in the matrix `C`\n* @param {NonNegativeInteger} N - number of columns in the matrix `op(B)` and in the matrix `C`\n* @param {NonNegativeInteger} K - number of columns in the matrix `op(A)` and number of rows in the matrix `op(B)`\n* @param {number} alpha - scalar constant\n* @param {Float64Array} A - first matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Float64Array} B - second matrix\n* @param {PositiveInteger} LDB - stride of the first dimension of `B` (a.k.a., leading dimension of the matrix `B`)\n* @param {number} beta - scalar constant\n* @param {Float64Array} C - third matrix\n* @param {PositiveInteger} LDC - stride of the first dimension of `C` (a.k.a., leading dimension of the matrix `C`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {TypeError} second argument must be a valid transpose operation\n* @throws {TypeError} third argument must be a valid transpose operation\n* @throws {RangeError} fourth argument must be a nonnegative integer\n* @throws {RangeError} fifth argument must be a nonnegative integer\n* @throws {RangeError} sixth argument must be a nonnegative integer\n* @throws {RangeError} ninth argument must be greater than or equal to max(1,M) when `A` is not transposed and max(1,K) otherwise\n* @throws {RangeError} eleventh argument must be greater than or equal to max(1,K) when `B` is not transposed and max(1,N) otherwise\n* @throws {RangeError} fourteenth argument must be greater than or equal to max(1,M)\n* @returns {Float64Array} `C`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( [ 1.0, 1.0, 0.0, 1.0 ] );\n* var C = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* dgemm( 'row-major', 'no-transpose', 'no-transpose', 2, 2, 2, 1.0, A, 2, B, 2, 1.0, C, 2 );\n* // C => <Float64Array>[ 2.0, 5.0, 6.0, 11.0 ]\n*/\nfunction dgemm( order, transA, transB, M, N, K, alpha, A, LDA, B, LDB, beta, C, LDC ) { // eslint-disable-line max-params, max-len\n\tvar nrowsa;\n\tvar nrowsb;\n\tvar valc;\n\tvar isrm;\n\tvar iscm;\n\tvar sa1;\n\tvar sa2;\n\tvar sb1;\n\tvar sb2;\n\tvar sc1;\n\tvar sc2;\n\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( !isMatrixTranspose( transA ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a valid transpose operation. Value: `%s`.', transA ) );\n\t}\n\tif ( !isMatrixTranspose( transB ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be a valid transpose operation. Value: `%s`.', transB ) );\n\t}\n\tif ( M < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be a nonnegative integer. Value: `%d`.', M ) );\n\t}\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be a nonnegative integer. Value: `%d`.', M ) );\n\t}\n\tif ( K < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be a nonnegative integer. Value: `%d`.', K ) );\n\t}\n\tisrm = isRowMajor( order );\n\tiscm = isColumnMajor( order );\n\tif (\n\t\t( isrm && transA === 'no-transpose' ) ||\n\t\t( iscm && transA === 'transpose' )\n\t) {\n\t\tnrowsa = K;\n\t} else {\n\t\tnrowsa = M;\n\t}\n\tif (\n\t\t( isrm && transB === 'no-transpose' ) ||\n\t\t( iscm && transB === 'transpose' )\n\t) {\n\t\tnrowsb = N;\n\t} else {\n\t\tnrowsb = K;\n\t}\n\tif ( LDA < max( 1, nrowsa ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Ninth argument must be greater than or equal to max(1,%d). Value: `%d`.', nrowsa, LDA ) );\n\t}\n\tif ( LDB < max( 1, nrowsb ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Eleventh argument must be greater than or equal to max(1,%d). Value: `%d`.', nrowsb, LDB ) );\n\t}\n\tif ( isrm ) {\n\t\tvalc = N;\n\t} else {\n\t\tvalc = M;\n\t}\n\tif ( LDC < max( 1, valc ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourteenth argument must be greater than or equal to max(1,%d). Value: `%d`.', valc, LDC ) );\n\t}\n\tif ( iscm ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t\tsb1 = 1;\n\t\tsb2 = LDB;\n\t\tsc1 = 1;\n\t\tsc2 = LDC;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t\tsb1 = LDB;\n\t\tsb2 = 1;\n\t\tsc1 = LDC;\n\t\tsc2 = 1;\n\t}\n\treturn base( transA, transB, M, N, K, alpha, A, sa1, sa2, 0, B, sb1, sb2, 0, beta, C, sc1, sc2, 0 ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nmodule.exports = dgemm;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isMatrixTranspose = require( '@stdlib/blas-base-assert-is-transpose-operation' );\nvar format = require( '@stdlib/string-format' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Performs the matrix-matrix operation `C = \u03B1*op(A)*op(B) + \u03B2*C` where `op(X)` is either `op(X) = X` or `op(X) = X^T`, `\u03B1` and `\u03B2` are scalars, `A`, `B`, and `C` are matrices, with `op(A)` an `M` by `K` matrix, `op(B)` a `K` by `N` matrix, and `C` an `M` by `N` matrix.\n*\n* @param {string} transA - specifies whether `A` should be transposed, conjugate-transposed, or not transposed\n* @param {string} transB - specifies whether `B` should be transposed, conjugate-transposed, or not transposed\n* @param {NonNegativeInteger} M - number of rows in the matrix `op(A)` and in the matrix `C`\n* @param {NonNegativeInteger} N - number of columns in the matrix `op(B)` and in the matrix `C`\n* @param {NonNegativeInteger} K - number of columns in the matrix `op(A)` and number of rows in the matrix `op(B)`\n* @param {number} alpha - scalar constant\n* @param {Float64Array} A - first matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @param {Float64Array} B - second matrix\n* @param {integer} strideB1 - stride of the first dimension of `B`\n* @param {integer} strideB2 - stride of the second dimension of `B`\n* @param {NonNegativeInteger} offsetB - starting index for `B`\n* @param {number} beta - scalar constant\n* @param {Float64Array} C - third matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @throws {TypeError} first argument must be a valid transpose operation\n* @throws {TypeError} second argument must be a valid transpose operation\n* @throws {RangeError} third argument must be a nonnegative integer\n* @throws {RangeError} fourth argument must be a nonnegative integer\n* @throws {RangeError} fifth argument must be a nonnegative integer\n* @throws {RangeError} seventeenth argument must be non-zero\n* @throws {RangeError} eighteenth argument must be non-zero\n* @returns {Float64Array} `C`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( [ 1.0, 1.0, 0.0, 1.0 ] );\n* var C = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* dgemm( 'no-transpose', 'no-transpose', 2, 2, 2, 1.0, A, 2, 1, 0, B, 2, 1, 0, 1.0, C, 2, 1, 0 );\n* // C => <Float64Array>[ 2.0, 5.0, 6.0, 11.0 ]\n*/\nfunction dgemm( transA, transB, M, N, K, alpha, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB, beta, C, strideC1, strideC2, offsetC ) { // eslint-disable-line max-params, max-len\n\tif ( !isMatrixTranspose( transA ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid transpose operation. Value: `%s`.', transA ) );\n\t}\n\tif ( !isMatrixTranspose( transB ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a valid transpose operation. Value: `%s`.', transB ) );\n\t}\n\tif ( M < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Third argument must be a nonnegative integer. Value: `%d`.', M ) );\n\t}\n\tif ( N < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be a nonnegative integer. Value: `%d`.', M ) );\n\t}\n\tif ( K < 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be a nonnegative integer. Value: `%d`.', K ) );\n\t}\n\tif ( strideC1 === 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Seventeenth argument must be non-zero. Value: `%d`.', strideC1 ) );\n\t}\n\tif ( strideC2 === 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Eighteenth argument must be non-zero. Value: `%d`.', strideC2 ) );\n\t}\n\treturn base( transA, transB, M, N, K, alpha, A, strideA1, strideA2, offsetA, B, strideB1, strideB2, offsetB, beta, C, strideC1, strideC2, offsetC ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nmodule.exports = dgemm;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar dgemm = require( './dgemm.js' );\nvar ndarray = require( './ndarray.js' );\n\n\n// MAIN //\n\nsetReadOnly( dgemm, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nmodule.exports = dgemm;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* BLAS level 3 routine to perform the matrix-matrix operation `C = \u03B1*op(A)*op(B) + \u03B2*C` where `op(X)` is either `op(X) = X` or `op(X) = X^T`, `\u03B1` and `\u03B2` are scalars, `A`, `B`, and `C` are matrices, with `op(A)` an `M` by `K` matrix, `op(B)` a `K` by `N` matrix, and `C` an `M` by `N` matrix.\n*\n* @module @stdlib/blas-base-dgemm\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var dgemm = require( '@stdlib/blas-base-dgemm' );\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( [ 1.0, 1.0, 0.0, 1.0 ] );\n* var C = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* dgemm( 'row-major', 'no-transpose', 'no-transpose', 2, 2, 2, 1.0, A, 2, B, 2, 1.0, C, 2 );\n* // C => <Float64Array>[ 2.0, 5.0, 6.0, 11.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var dgemm = require( '@stdlib/blas-base-dgemm' );\n*\n* var A = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var B = new Float64Array( [ 1.0, 1.0, 0.0, 1.0 ] );\n* var C = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n*\n* dgemm.ndarray( 'no-transpose', 'no-transpose', 2, 2, 2, 1.0, A, 2, 1, 0, B, 2, 1, 0, 1.0, C, 2, 1, 0 );\n* // C => <Float64Array>[ 2.0, 5.0, 6.0, 11.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nvar tryRequire = require( '@stdlib/utils-try-require' );\nvar isError = require( '@stdlib/assert-is-error' );\nvar main = require( './main.js' );\n\n\n// MAIN //\n\nvar dgemm;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdgemm = main;\n} else {\n\tdgemm = tmp;\n}\n\n\n// EXPORTS //\n\nmodule.exports = dgemm;\n\n// exports: { \"ndarray\": \"dgemm.ndarray\" }\n"],
  "mappings": "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",
  "names": ["require_base", "__commonJSMin", "exports", "module", "isRowMajor", "ddot", "blockSize", "bsize", "isTransposed", "str", "zeros", "M", "N", "X", "strideX1", "strideX2", "offsetX", "dx0", "dx1", "S0", "S1", "i0", "i1", "ix", "scal", "beta", "naive", "K", "alpha", "A", "strideA1", "strideA2", "offsetA", "B", "strideB1", "strideB2", "offsetB", "C", "strideC1", "strideC2", "offsetC", "da0", "db0", "dc0", "dc1", "ia", "ib", "ic", "blocked", "oa1", "ob0", "oc0", "oc1", "s0", "s1", "sk", "j0", "j1", "oa", "ob", "dgemm", "transA", "transB", "isrma", "isrmb", "sa1", "sa2", "sb1", "sb2", "require_dgemm", "__commonJSMin", "exports", "module", "max", "isLayout", "isMatrixTranspose", "isRowMajor", "isColumnMajor", "format", "base", "dgemm", "order", "transA", "transB", "M", "N", "K", "alpha", "A", "LDA", "B", "LDB", "beta", "C", "LDC", "nrowsa", "nrowsb", "valc", "isrm", "iscm", "sa1", "sa2", "sb1", "sb2", "sc1", "sc2", "require_ndarray", "__commonJSMin", "exports", "module", "isMatrixTranspose", "format", "base", "dgemm", "transA", "transB", "M", "N", "K", "alpha", "A", "strideA1", "strideA2", "offsetA", "B", "strideB1", "strideB2", "offsetB", "beta", "C", "strideC1", "strideC2", "offsetC", "require_main", "__commonJSMin", "exports", "module", "setReadOnly", "dgemm", "ndarray", "join", "tryRequire", "isError", "main", "dgemm", "tmp"]
}
